
{-# LANGUAGE RankNTypes, ExistentialQuantification, GeneralizedNewtypeDeriving #-}

{-|
Alan is a HTTP/REST server and library that compiles and executes Haskell code on-the-fly.

Alan leverages Stack to support multiple language environments (called /stages/),
which can be configured to run a specified /dialect/ of the Haskell language, by
specifying GHC version, compiler options and packages.

Users invoke Alan by submitting a set of Haskell modules, which are immediately
type-checked and launched. The resultant process is called a /performer/.

Each performer runs into a sandboxed environment and can not access memory, files,
environment of other performers, or the underlying system. Otherwise they can
perform arbitrary computation and respond to requests via the Alan system that
launched them.

The Safe Haskell mode is used to enforce this:
<https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe-haskell.html>

@
Usage:
  alan serve --port 8675 &

  alan add-stage mystage
  alan start --url localhost --port 8675 mystage -I . Main.hs
    Launches a new service, prints process ID.
  alan send localhost a2b4c1b2 {"command":"status"}
@
-}
module Alan (
  AlanServerError,
  Message,
  Persistent,

  AlanConfiguration(..),
  defAlanConfiguration,

  AlanServer,
  runAlanServer,

  Stage,
  Performer,
  Package,
  SourceTree,
  addStage,
  start,
  send
  ) where

{-
Design notes:
  Write as a library (Alan.hs)
    Wrap as a HTTP server (Alan/Server.hs) and client (Alan/Client.hs)
    Top-level execitable alan (Alan/Main.hs) invokes either
    Keep top-level API simple (< 5 functions)

    Compiled modules can NOT access the IO monad. This is enforced as follows:
      Safe Haskell is used to compile user code
      User code is not allowed to define @Main.main@ (in safe Haskell, the only way to run an IO computation is to be invoked by main)
      Instead, they define Main.alanMain, which is invoked by a main function generated by alan.

    What type is Main.alanMain? It should be something simple that does not require user code to import Alan.
    Libraries can be written to facilitate use of this type later on (i.e. an Alan) monad.

    The server runs in a single Alan directory, where all the stages (housing package-dbs) and performers (housing sources and artefacts) are stored.
      The Alan directory should NOT be shared between server processes.
      All persistant state is stored in the Alan directory. Note that the AlanServer monad is conceptually effect-free,
      so anything created in the Alan directory should be for caching/optimization purposes and not affect behavior at all.
    The AlanServer monad is sequential but not thread-safe.
      COROLLARY
        Any invocation of AlanServer methods from server wrappers must be queued.

    The API is deliberately vague about HOW the submitted code is executed, as part of point of Alan is to hide system-specific details.

    There are serveral implementation choices:
      - Is the code compiled or interpreted?
      - Are package databases used, or some other linking strategy (i.e. package mangling, interpreting everything).
      - What compiler/interpreter is used (GHC-n, GHCJS, other?).
      - How are package databases (if used) created (stack, cabal-install, ghc-pkg, manually)
      - How are the processes launched?
      - How does communication between the processes and Alan (hence the world) happen. File handles, sockets, runtime linking,
        shared memory etc.
-}

import Control.Monad.Except
import Control.Monad.Reader
import Data.Supply
import Data.Version
import System.Process
import qualified Control.Exception
import qualified System.IO

-- For hash
import qualified Data.Aeson
import Data.Aeson (ToJSON, FromJSON)
import qualified Numeric
import qualified Crypto.Hash.MD5 as MD5
import Data.ByteString as LBS
import qualified System.Directory
import qualified System.Process
import qualified Data.Maybe
import qualified Data.Map as Map

import qualified System.Environment
import qualified System.FilePath.Posix as FilePath

import System.Exit (ExitCode(..))


-- API

type AlanServerError = String

data AlanConfiguration  = AlanConfiguration {
  -- At the moment, each Alan server requires a preinstalled GHC and Cabal
  -- Might be changed
  alanConfGhcExecutable :: FilePath,
  alanConfCabalExecutable         :: FilePath,
  alanConfAlanDirectory :: Maybe FilePath
  }
defAlanConfiguration = AlanConfiguration {
  alanConfGhcExecutable = "/usr/bin/ghc",
  alanConfCabalExecutable         = "/usr/bin/cabal",
  alanConfAlanDirectory = Nothing
  }


type Message = String -- TODO JSON
type Persistent = String -- TODO JSON

newtype AlanState = AlanState { alanStateConf :: AlanConfiguration }

-- All persistant state is stored in the Alan directory
-- All processes spawned by Alan are non-daemons, so no process leaks are possible
newtype AlanServer a = AlanServer
  (ReaderT AlanState
    (ExceptT AlanServerError IO)
    a)
    deriving (Functor, Applicative, Monad, MonadError AlanServerError, MonadIO, MonadReader AlanState)

-- Server is started with
runAlanServer
    :: AlanConfiguration
    -> AlanServer a
    -> IO (Either String a)
runAlanServer conf (AlanServer x) = runExceptT (runReaderT x (AlanState conf))

data Stage = Stage String -- Must be JSONable
  deriving (Show)
data Performer = Performer String -- Must be JSONable
  deriving (Show)

type Package    = (String, Version) -- I.e. [("aeson", fromString "0.10.0.0")]
type SourceTree = [(FilePath, String)] -- I.e. [("Main.hs","module Main where alan = ...")]

-- For now, document that only one instance of alan should be run over an alan directory (they can run over different directories though)
-- Eventually lock on PID or similar (i.e. alan server writes its PID to the alan dir before operating and refuses to proceed
-- if a process with that PID exists on the system)

-- | Create a new stage.
addStage :: [Package] -> AlanServer Stage
addStage dependencies = do
  let overwrite = False

  -- TODO cabal impl does not work if (null dependencies)

  -- Generate stage ID (hash of deps)
  let stageId = hashJson $ (fmap (fmap show) dependencies)
  homeDir <- liftIOWithException $ System.Directory.getHomeDirectory
  alanDir <- fmap (Data.Maybe.fromMaybe (homeDir ++ "/.alan") . alanConfAlanDirectory . alanStateConf) ask
  cabalExe <- fmap (alanConfCabalExecutable . alanStateConf) ask
  ghcExe   <- fmap (alanConfGhcExecutable . alanStateConf) ask
  let stageDir = alanDir ++ "/" ++ stageId

  there <- liftIOWithException $ System.Directory.doesDirectoryExist stageDir
  when (there && overwrite) $ liftIOWithException $ System.Directory.removeDirectoryRecursive stageDir

  -- TODO Stack implementation
  -- Instead of the sandbox, create a dummy stack project (generate stack.yaml and a dummy library if needed)
  -- When compiling, concatenate GHC pack-db, lts pack-db (in .stack directory), and pack-db in stage.

  cabalEnv <- liftIOWithException $ overwriteEnvironment "FOO" "bar"

  unless there $ do
    liftIOWithException $ System.Directory.createDirectoryIfMissing True stageDir
    -- TODO cabal path
    (_,_,_,p) <- liftIOWithException $ System.Process.createProcess $ (\x -> x { cwd = Just stageDir, env = cabalEnv })
      $ System.Process.proc cabalExe ["sandbox", "init", "--sandbox", stageDir ++ "/sb"]
    r <- liftIOWithException $ System.Process.waitForProcess p
    case r of
      ExitSuccess -> return ()
      ExitFailure e -> throwError $ cabalExe ++ " exited with code: " ++ show e
    return ()

    (_,_,_,p) <- liftIOWithException $ System.Process.createProcess $ (\x -> x { cwd = Just stageDir, env = cabalEnv })
      $ System.Process.proc cabalExe (["-j", "install"]
        ++ fmap (\(name,version) -> name ++ "-" ++ showVersion version)
        dependencies)
    r <- liftIOWithException $ System.Process.waitForProcess p
    case r of
      ExitSuccess -> return ()
      ExitFailure e -> throwError $ cabalExe ++ " exited with code: " ++ show e
    return ()

  return $ Stage stageId
    -- If Bool is true, wipe out preexisting stage and restart
    -- Create stage if not existing
      -- Go to SB dir
      -- <alanDir>/stages/a12b2246
      -- Run cabal sandbox init
      -- Run cabal sandbox install [packages]
    -- Return Stage (with id)

-- | Start a new performer using the given stage.
start :: Stage -> SourceTree -> AlanServer Performer
start (Stage stageId) sources = do
  let performerId = hashJson $ (sources,stageId)
  homeDir  <- liftIOWithException $ System.Directory.getHomeDirectory
  alanDir  <- fmap (Data.Maybe.fromMaybe (homeDir ++ "/.alan") . alanConfAlanDirectory . alanStateConf) ask
  cabalExe <- fmap (alanConfCabalExecutable . alanStateConf) ask
  ghcExe   <- fmap (alanConfGhcExecutable . alanStateConf) ask

  -- Generate performer id (stageId+unique Message)
  let stageDir     = alanDir ++ "/" ++ stageId
  -- TODO replace arch/OS/GHC version here by parsing cabal.sandbox.config and looking at package-db: field
  let packDbDir    = stageDir ++ "/sb/x86_64-osx-ghc-7.10.2-packages.conf.d"
  let performerDir = alanDir ++ "/performers/" ++ performerId

  -- TODO ghc path
  there <- liftIOWithException $ System.Directory.doesDirectoryExist performerDir
  unless there $ do
    liftIOWithException $ System.Directory.createDirectoryIfMissing True performerDir
    return ()

  -- Note: If the performer directory existed, files should exist too, but rewrite in case a file was accidentally removed
  -- Note that GHC won't recompile unless checksums are different
  forM_ sources $ \(path,code) -> do
    liftIOWithException $ System.Directory.createDirectoryIfMissing True (FilePath.takeDirectory (performerDir ++ "/" ++ path))
    liftIOWithException $ System.IO.writeFile (performerDir ++ "/" ++ path) code
    return ()

  (_,_,_,p) <- liftIOWithException $ System.Process.createProcess $ (\x -> x { cwd = Just performerDir, env = inheritCompleteEnvironment }) $
    System.Process.proc ghcExe [
      "-package-db=" ++ packDbDir,
      "-threaded",
      "-O2",
      "-XSafe",
      "-i" ++ performerDir, -- or .
      "--make", "Main.hs",
      "-o", performerDir ++ "/AlanMain"
      ]
  r <- liftIOWithException $ System.Process.waitForProcess p
  case r of
    ExitSuccess -> return ()
    ExitFailure e -> throwError $ ghcExe ++ " exited with code: " ++ show e
  (_,_,_,p) <- liftIOWithException $ System.Process.createProcess $ (\x -> x { cwd = Just performerDir, env = emptyEnvironment }) $
    System.Process.proc (performerDir ++ "/AlanMain") []

  -- Go to perf dir, place sources here
    -- <alanDir>/performers/<performerId>
  -- Add wrapping alanMain
  -- Compile or interpret this code with stage pack-db, launch result
  -- Performers are NOT daemons

-- compile/eval code, using package DBs from Stage
  return $ Performer performerId


-- | Send a message to the given perfomer.
send :: Performer -> Message -> AlanServer ()
  -- Write to input
  -- Block waiting for output

[send] = undefined

-- -- The running procs are restricted to this type
-- data AlanProc = forall s . AlanProc (Maybe Persistent -> (s, Message -> s -> (Maybe Persistent, Maybe Message, s)))
-- -- TODO Al monad
-- -- runAl Al () -> AlanProc
-- alanId :: AlanProc
-- alanId = AlanProc $ \_ -> ((), \m () -> (Nothing, Just m, ()))
--
-- -- TODO remove Main from incoming code and add something like this
-- alanMain :: AlanProc -> IO ()
-- alanMain (AlanProc startup) = do
--   -- Messages are lines to stdin/stdout (TODO escape newlines, or even use fancy binary modes)
--   -- Persistance not implemented (requires identiciation of processes as per above)
--   let (initState, update) = startup Nothing
--   recur update initState
--   where
--     recur update state = do
--         msg <- System.IO.getLine
--         let (_, mOut, state') = update msg state
--         -- send message
--         case mOut of
--           Nothing -> return ()
--           Just msg -> System.IO.putStrLn msg
--         recur update state'

-- UTIL

inheritCompleteEnvironment :: Maybe [(String, String)]
inheritCompleteEnvironment = Nothing

emptyEnvironment :: Maybe [(String, String)]
emptyEnvironment = Just []

overwriteEnvironment :: String -> String -> IO (Maybe [(String, String)])
overwriteEnvironment k v = do
  base <- fmap Map.fromList $ System.Environment.getEnvironment
  return $ Just $ Map.toList (Map.insert k v base)

-- | Hash any object with a JSON representation
hashJson :: ToJSON a => a -> String
hashJson = (=<<) (twoChars . ($ "") . Numeric.showHex) . LBS.unpack .  toHash
  where
        toHash = MD5.hashlazy . Data.Aeson.encode
        twoChars [a   ] = ['0', a]
        twoChars [a, b] = [a,   b]

liftIOWithException :: IO a -> AlanServer a
liftIOWithException k = liftIO (Control.Exception.try k) >>= \x -> case x of
  Left e  -> throwError $ show (e :: Control.Exception.SomeException)
  Right x -> return x
